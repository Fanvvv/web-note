# 初识 webpack

webpack是一个**静态的模块化打包工具**，为现代的JavaScript应用程序。

我们来对上面的解释进行拆解： 

- 打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具 
- 静态的static：这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）
- 模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等 
- 现代的modern：我们前端说过，正是因为现代前端开发面临各种各样的问题，才催生了webpack的出现和发展

![image-20240821100136271](1.%E5%88%9D%E5%A7%8Bwebpack.assets/image-20240821100136271.png)

## 结构化理解 webpack 配置项

可以将webpack 的编译流程简化为：

:::tip 编译流程

输入 -> 模块处理 -> 后处理 -> 输出

:::

- **输入**：从文件系统读入代码文件；
- **模块递归处理**：调用 Loader 转译 Module 内容，并将结果转换为 AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；
- **后处理**：所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 Chunk 集合；
- **输出**：将 Chunk 写出到外部文件系统；

### 流程类配置项

与打包流程强相关的配置项有：

- 输入输出：
  - `entry`：用于定义项目入口文件，Webpack 会从这些入口文件开始按图索骥找出所有项目文件；
  - `context`：项目执行上下文路径；
  - `output`：配置产物输出路径、名称等；
- 模块处理：
  - `resolve`：用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块
  - `module`：用于配置模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理
  - `externals`：用于声明外部资源，Webpack 会直接忽略这部分资源，跳过这些资源的解析、打包操作
- 后处理：
  - `optimization`：用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能
  - `target`：用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异
  - `mode`：编译模式短语，支持 `development`、`production` 等值，可以理解为一种声明环境的短语

### 工具类配置项

除了核心的打包功能之外，Webpack 还提供了一系列用于提升研发效率的工具，大体上可划分为：

- 开发效率类：
  - `watch`：用于配置持续监听文件变化，持续构建
  - `devtool`：用于配置产物 Sourcemap 生成规则
  - `devServer`：用于配置与 HMR 强相关的开发服务器功能
- 性能优化类：
  - `cache`：Webpack 5 之后，该项用于控制如何缓存编译过程信息与编译结果
  - `performance`：用于配置当产物大小超过阈值时，如何通知开发者
- 日志类：
  - `stats`：用于精确地控制编译过程的日志内容，在做比较细致的性能调试时非常有用
  - `infrastructureLogging`：用于控制日志输出方式，例如可以通过该配置将日志输出到磁盘文件
- 等等

## 简单的案例理解配置逻辑

文件目录结构

```bash
.
├── src
|   └── index.js
└── webpack.config.js
```

进行 webpack 配置

```js
// webpack.config.js
const { resolve } = require('path')

module.exports = () => ({
  mode: 'none',
  entry: {
    main: './src/index.js'
  },
  output: {
    filename: '[name].js',
    path: resolve(__dirname, './dist')
  },
})
```

mode：有development（开发环境）、production（生产环境）和none三个选项

`./src/index.js` 就是项目的入口文件，输出内容会在当前配置文件下新建一个 `dist` 目录，存放打包后的文件。

> 需要安装 webpack、webpack-cli，然后执行 webpack 命令 即可打包

输入后的结果

```bash
.
├── dist
|   └── main.js
├── src
|   └── index.js
└── webpack.config.js
```

这个案例中只有js文件，但在实际开发中，往往是有很多其他文件的，比如 css，png，svg....等等等。需要借助 Loader 来识别它们（根据文件的不同使用不同的loader来解析）

## Loader 和 Plugin

loader 可以用于对模块的源代码进行转换

### Loader 的配置方式

在 `webpack.config.js` 中 `module.rules` 中允许我们配置多个 loader。rules属性对应的值是一个数组。

数组中存放的是一个个的Rule，Rule是一个对象，对象中可以设置多个属性： [Rule]

- test属性：用于对 resource（资源）进行匹配的，通常会设置成正则表达式； 
- use属性：对应的值时一个数组：[UseEntry] 
  - UseEntry是一个对象，可以通过对象的属性来设置一些其他属性 
    -  loader：必须有一个 loader属性，对应的值是一个字符串； 
    - options：可选的属性，值是一个字符串或者对象，值会被传入到loader中； 
    - query：目前已经使用options来替代； 
  - 传递字符串（如：use: [ 'style-loader' ]）是 loader 属性的简写方式（如：use: [ { loader: 'style-loader'} ]）； 
- loader属性： Rule.use: [ { loader } ] 的简写。

## webpack 处理 css 资源

我们可以将css文件也看成是一个模块，我们是通过import来加载这个模块的，在加载这个模块时，webpack其实并不知道如何对其进行加载，我们必须制定对应的 loader 来完成这个功能。

### css-loader

css-loader 就是用来解析 css 文件的，该 loader 会将 css 等价翻译为 `module.exports = "${css}" ` 的js代码

案例：编写 component.js，在页面上添加有颜色的文字

```js
import "./assets/css/index.css";

function component() {
  const element = document.createElement("div");

  element.innerHTML = ["Hello", "Webpack"].join(" ");

  element.classList.add("content");

  return element;
}

document.body.appendChild(component());
```

```css
.content {
  color: red;
  font-size: 20px;
}
```

将 component.js 写入到配置的入口中

```js
entry: {
    main: './src/index.js',
    component: './src/component.js'
},
```

打包会发现，webpack 解析模块失败了

![image-20240821142501195](1.%E5%88%9D%E5%A7%8Bwebpack.assets/image-20240821142501195.png)

我们需要引入 css-loader 对 css 模块进行解析

```bash
npm i css-loader -D
```

添加配置

```js
module: {
    rules: [{
        test: /\.css$/i,
        use: ['css-loader']
    }]
}
```

重新打包即可完成打包。编译完成后的css 会是一段 js字符串

```js
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.content {
  color: red;
  font-size: 20px;
}
`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);
```

得到js代码后，还是预览不到效果，需要将代码注入到他们的 `style` 标签中，便会使样式生效，这就需要使用 style-loader 来实现

### style-loader

style-loader 大多都用于开发环境

安装

```bash
npm install style-loader -D
```

在配置的时候需要注意的是，loader 是有顺序的，是从右到左（换行的话可以说是从上到下），相当于链式调用 `style-loader(css-loader(css))`

```js
module: {
    rules: [{
        test: /\.css$/i,
        // 先解析css，再插入到页面
        use: ['style-loader', 'css-loader']
    }]
}
```

![image-20240821153020342](1.%E5%88%9D%E5%A7%8Bwebpack.assets/image-20240821153020342.png)

这种将 JS、CSS 代码合并进同一个产物文件的方式有几个问题：

- JS、CSS 资源无法并行加载，从而降低页面性能；
- 资源缓存粒度变大，JS、CSS 任意一种变更都会致使缓存失效。

所以 style-loader 在生产环境中不使用，使用 `mini-css-extract-plugin` 插件代替 `style-loader`，将样式代码抽离成单独的css 文件。

### mini-css-extract-plugin

用于抽离 css

安装

```bash
npm i mini-css-extract-plugin -D
```

配置：在开发环境使用 style-loader，在生产环境使用 mini-css-extract-plugin 插件

```js
const { resolve } = require('path')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = () => ({
  mode: 'none',
  entry: {
    main: './src/index.js',
    component: './src/component.js'
  },
  output: {
    filename: '[name].js',
    path: resolve(__dirname, './dist')
  },
  module: {
    rules: [{
      test: /\.css$/i,
      use: [
        // 根据运行环境判断使用那个 loader
        (process.env.NODE_ENV === 'development' ?
          'style-loader' :
          MiniCssExtractPlugin.loader),
        'css-loader'
      ]
    }]
  },
  plugins: [
    new MiniCssExtractPlugin(),
    new HtmlWebpackPlugin()
  ]
})
```

打包后的css就是抽离出来了的

![image-20240821154856127](1.%E5%88%9D%E5%A7%8Bwebpack.assets/image-20240821154856127.png)

需要注意的是：

- `mini-css-extract-plugin` 库同时提供 Loader、Plugin 组件，需要同时使用
- `mini-css-extract-plugin` 不能与 `style-loader` 混用，否则报错
- `mini-css-extract-plugin` 需要与 `html-webpack-plugin` 同时使用，才能将产物路径以 `link` 标签方式插入到 html 中

![image-20240821155046155](1.%E5%88%9D%E5%A7%8Bwebpack.assets/image-20240821155046155.png)

### 预处理器 less、sass、stylus

在项目开发的时候，经常会使用到一些预处理器，可以借助相应的 loader 将它们先转成 css

以 less 为例：

```less
@color: blue;
@fontSize: 24px;

.content {
    color: @color;
    font-size: @fontSize;
}
```

安装 less 和 less-loader

```bash
npm i less less-loader -D
```

配置

```js
module.exports = {
  module: {
    rules: [{
      test: /\.less$/i,
      use: [
        // 根据运行环境判断使用那个 loader
        (process.env.NODE_ENV === 'development' ?
          'style-loader' :
          MiniCssExtractPlugin.loader),
        'css-loader',
        'less-loader'
      ]
    }]
  },
}
```

其他预处理器

**sass**

```bash
npm i -D sass sass-loader 
```

```js
module.exports = {
    module: {
        rules: [{
          test: /\.s(ac)ss$/i,
          use: [
            'style-loader',
            'css-loader',
        	'sass-loader'
          ]
        }]
    }
}
```

**stylus**

```bash
npm i -D stylus stylus-loader
```

```js
module.exports = {
    module: {
        rules: [{
          test: /\.styl$/i,
          use: [
            'style-loader',
            'css-loader',
        	'stylus-loader'
          ]
        }]
    }
}
```

### PostCSS

PostCSS 并没有定义一门新的语言，只是实现了一套将 CSS 源码解析为 AST 结构，并传入 PostCSS 插件做处理的流程框架，具体功能都是由插件实现。这个工具可以帮助我们进行一些CSS的转换和适配，比如自动添加浏览器前缀、css样式的重置。

> 预处理器之于 CSS，就像 TypeScript 与 JavaScript 的关系；而 PostCSS 之于 CSS，则更像 Babel 与 JavaScript。

自动添加浏览器前缀案例：

```bash
npm i postcss postcss-loader autoprefixer -D
```

通过 `webpack.config.js` 来配置

```js
module: {
    rules: [{
      test: /\.css$/i,
      use: [
        // 根据运行环境判断使用那个 loader
        (process.env.NODE_ENV === 'development' ?
          'style-loader' :
          MiniCssExtractPlugin.loader),
        'css-loader',
        {
          loader: "postcss-loader",
          options: {
            postcssOptions: {
              // 添加 autoprefixer 插件
              plugins: [require("autoprefixer")],
            },
          },
        }
      ]
    }]
}
```

也可以抽离出来，通过 `postcss.config.js` 配置文件来进行配置

```js
module.exports = {
  plugins: [
    require('autoprefixer')
  ]
}
```

拿 `user-select: none;` 来举例

```css
.content {
  color: blue;
  font-size: 24px;
  user-select: none;
}
```

经过插件处理后自动加上了浏览器前缀

```css
.content {
  color: blue;
  font-size: 24px;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}
```

PostCSS 最大的优势在于其简单、易用、丰富的插件生态，基本上已经能够覆盖样式开发的方方面面。实践中，经常使用的插件有：

- [autoprefixer](https://github.com/postcss/autoprefixer)：基于 [Can I Use](https://caniuse.com/) 网站上的数据，自动添加浏览器前缀
- [postcss-preset-env](https://github.com/jonathantneal/postcss-preset-env)：一款将最新 CSS 语言特性转译为兼容性更佳的低版本代码的插件，比如他会将8位数的颜色格式转为RGBA格式的颜色，并且它内置了 autoprefixer 功能。
- [postcss-less](https://github.com/shellscape/postcss-less)：兼容 Less 语法的 PostCSS 插件，类似的还有：[postcss-sass](https://github.com/AleshaOleg/postcss-sass)、[poststylus](https://github.com/madeleineostoja/poststylus)
- [stylelint](https://github.com/stylelint/stylelint)：一个现代 CSS 代码风格检查器，能够帮助识别样式代码中的异常或风格问题

## 指定配置文件运行

如果我们将`webpack.config.js` 的名字改为 `wp.config.js`，在`package.json` 中可以修改脚本，也可以在命令行直接运行 `webpack --config wp.config.js`

```json
{
    "script": {
        "build": "webpack --config wp.config.js"
    }
}
```

直接 `npm run build` 就可以执行了
